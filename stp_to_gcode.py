#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
STP文件转G代码转换器
此脚本读取STEP格式的CAD文件并生成适合3D打印或CNC加工的G代码
"""

import sys
import os
import argparse
import math
import numpy as np
from time import time

try:
    from OCC.Core.STEPControl import STEPControl_Reader
    from OCC.Core.IFSelect import IFSelect_RetDone, IFSelect_ItemsByEntity
    from OCC.Core.GeomAbs import GeomAbs_Line, GeomAbs_Circle
    from OCC.Core.BRepAdaptor import BRepAdaptor_Curve
    from OCC.Core.TopAbs import TopAbs_EDGE, TopAbs_FACE
    from OCC.Core.TopExp import TopExp_Explorer
    from OCC.Core.TopoDS import topods_Edge, topods_Face, TopoDS_Iterator
    from OCC.Core.BRep import BRep_Tool
    from OCC.Core.BRepMesh import BRepMesh_IncrementalMesh
    from OCC.Core.Bnd import Bnd_Box
    from OCC.Core.BRepBndLib import brepbndlib_Add
    from OCC.Extend.TopologyUtils import TopologyExplorer
except ImportError:
    print("错误: 需要安装PythonOCC库")
    print("安装命令: pip install PythonOCC-Core")
    sys.exit(1)

class StepToGcode:
    def __init__(self, input_file, output_file=None, feed_rate=500, 
                 rapid_feed_rate=1000, safety_height=5.0, cut_depth=0.5, 
                 tool_diameter=3.0, xy_tolerance=0.01):
        """
        初始化STEP到G代码转换器
        
        Args:
            input_file (str): 输入STP文件路径
            output_file (str): 输出G代码文件路径
            feed_rate (float): 加工进给率 (mm/min)
            rapid_feed_rate (float): 快速移动进给率 (mm/min)
            safety_height (float): 安全高度 (mm)
            cut_depth (float): 每次切割深度 (mm)
            tool_diameter (float): 刀具直径 (mm)
            xy_tolerance (float): XY平面公差 (mm)
        """
        self.input_file = input_file
        self.output_file = output_file or self._default_output_file()
        self.feed_rate = feed_rate
        self.rapid_feed_rate = rapid_feed_rate
        self.safety_height = safety_height
        self.cut_depth = cut_depth
        self.tool_diameter = tool_diameter
        self.xy_tolerance = xy_tolerance
        
        self.current_z = 0.0
        self.current_x = 0.0
        self.current_y = 0.0
        
        self.gcode_lines = []
        self.bounds = None

    def _default_output_file(self):
        """为输入文件生成默认的输出文件名"""
        base = os.path.splitext(self.input_file)[0]
        return f"{base}.gcode"

    def load_step_file(self):
        """加载STEP文件并返回形状"""
        start_time = time()
        print(f"正在加载STEP文件: {self.input_file}")
        
        step_reader = STEPControl_Reader()
        status = step_reader.ReadFile(self.input_file)
        
        if status != IFSelect_RetDone:
            raise ValueError(f"无法读取STEP文件: {self.input_file}")
        
        step_reader.TransferRoots()
        shape = step_reader.Shape()
        
        print(f"STEP文件加载完成，用时 {time() - start_time:.2f} 秒")
        return shape

    def get_bounding_box(self, shape):
        """获取形状的边界框"""
        bbox = Bnd_Box()
        bbox.SetGap(1e-5)
        
        # 创建网格以获取更精确的边界
        mesh = BRepMesh_IncrementalMesh(shape, 0.1)
        mesh.Perform()
        
        brepbndlib_Add(shape, bbox)
        
        xmin, ymin, zmin, xmax, ymax, zmax = bbox.Get()
        print(f"模型边界: X: {xmin:.2f} to {xmax:.2f}, Y: {ymin:.2f} to {ymax:.2f}, Z: {zmin:.2f} to {zmax:.2f}")
        
        self.bounds = (xmin, ymin, zmin, xmax, ymax, zmax)
        return self.bounds

    def write_gcode_header(self):
        """写入G代码文件头"""
        self.gcode_lines.extend([
            "(Generated by STP to G-code Converter)",
            f"(Input file: {self.input_file})",
            f"(Date: {time()})",
            "",
            "G90 ; 绝对坐标模式",
            "G21 ; 使用毫米",
            "G17 ; XY平面选择",
            f"G0 Z{self.safety_height} ; 提升到安全高度",
            "G0 X0 Y0 ; 移动到起始位置",
            ""
        ])

    def write_gcode_footer(self):
        """写入G代码文件尾"""
        self.gcode_lines.extend([
            "",
            f"G0 Z{self.safety_height} ; 提升到安全高度",
            "G0 X0 Y0 ; 返回起始位置",
            "M5 ; 关闭主轴",
            "M30 ; 程序结束"
        ])

    def explore_edges(self, shape):
        """探索并处理形状中的所有边"""
        explorer = TopExp_Explorer(shape, TopAbs_EDGE)
        
        edge_count = 0
        while explorer.More():
            edge = topods_Edge(explorer.Current())
            self.process_edge(edge)
            edge_count += 1
            explorer.Next()
        
        print(f"处理了 {edge_count} 条边")

    def process_edge(self, edge):
        """处理单条边并生成相应的G代码"""
        curve_adaptor = BRepAdaptor_Curve(edge)
        curve_type = curve_adaptor.GetType()
        
        # 获取边的起点和终点
        start_point = curve_adaptor.Value(curve_adaptor.FirstParameter())
        end_point = curve_adaptor.Value(curve_adaptor.LastParameter())
        
        start_x, start_y, start_z = start_point.X(), start_point.Y(), start_point.Z()
        end_x, end_y, end_z = end_point.X(), end_point.Y(), end_point.Z()
        
        # 判断是否需要进行Z轴调整
        z_level = min(start_z, end_z)
        
        # 如果当前位置离起点很远，先快速移动到起点上方
        if (abs(self.current_x - start_x) > self.xy_tolerance or 
            abs(self.current_y - start_y) > self.xy_tolerance):
            self.gcode_lines.append(f"G0 Z{self.safety_height} ; 提升到安全高度")
            self.gcode_lines.append(f"G0 X{start_x:.4f} Y{start_y:.4f} ; 快速移动到下一个轮廓起点")
            self.gcode_lines.append(f"G1 Z{z_level:.4f} F{self.feed_rate} ; 下降到切割高度")
            self.current_z = z_level
        
        # 根据曲线类型生成G代码
        if curve_type == GeomAbs_Line:
            # 直线
            self.gcode_lines.append(f"G1 X{end_x:.4f} Y{end_y:.4f} Z{end_z:.4f} F{self.feed_rate} ; 直线移动")
        
        elif curve_type == GeomAbs_Circle:
            # 圆或圆弧
            circle = curve_adaptor.Circle()
            center = circle.Location()
            radius = circle.Radius()
            
            # 计算圆心坐标
            center_x, center_y = center.X(), center.Y()
            
            # 计算起点和终点相对于圆心的角度
            start_angle = math.atan2(start_y - center_y, start_x - center_x)
            end_angle = math.atan2(end_y - center_y, end_x - center_x)
            
            # 确定是顺时针还是逆时针
            # 注意：这种简单判断在某些情况下可能不准确
            if end_angle < start_angle:
                # 顺时针
                g_command = "G2"
            else:
                # 逆时针
                g_command = "G3"
            
            # 圆弧的I, J值（相对于起点的圆心偏移）
            i_value = center_x - start_x
            j_value = center_y - start_y
            
            self.gcode_lines.append(f"{g_command} X{end_x:.4f} Y{end_y:.4f} Z{end_z:.4f} I{i_value:.4f} J{j_value:.4f} F{self.feed_rate} ; 圆弧移动")
        
        else:
            # 对于其他类型的曲线，使用离散点近似
            # 这里简化处理，实际应用中可能需要更复杂的算法
            self.gcode_lines.append(f"G1 X{end_x:.4f} Y{end_y:.4f} Z{end_z:.4f} F{self.feed_rate} ; 近似曲线")
        
        # 更新当前位置
        self.current_x, self.current_y, self.current_z = end_x, end_y, end_z

    def explore_faces(self, shape):
        """探索并处理形状中的所有面"""
        explorer = TopExp_Explorer(shape, TopAbs_FACE)
        
        face_count = 0
        while explorer.More():
            face = topods_Face(explorer.Current())
            self.process_face(face)
            face_count += 1
            explorer.Next()
        
        print(f"处理了 {face_count} 个面")

    def process_face(self, face):
        """处理单个面并生成相应的G代码"""
        # 对于平面，我们可以处理其边界
        wire_explorer = TopologyExplorer(face)
        for wire in wire_explorer.wires():
            # 针对每个环（外环或内环）
            edge_explorer = TopologyExplorer(wire)
            for edge in edge_explorer.edges():
                self.process_edge(edge)

    def convert(self):
        """执行转换过程"""
        try:
            # 加载STEP文件
            shape = self.load_step_file()
            
            # 获取边界框
            self.get_bounding_box(shape)
            
            # 写入G代码头部
            self.write_gcode_header()
            
            # 选择处理方式：
            # 对于简单零件，可以只处理边缘
            self.explore_edges(shape)
            
            # 对于复杂零件，可能需要处理面
            # self.explore_faces(shape)
            
            # 写入G代码尾部
            self.write_gcode_footer()
            
            # 保存G代码到文件
            with open(self.output_file, 'w') as f:
                f.write('\n'.join(self.gcode_lines))
            
            print(f"G代码已生成并保存到: {self.output_file}")
            print(f"共生成 {len(self.gcode_lines)} 行G代码")
            
            return True
            
        except Exception as e:
            print(f"转换过程中出错: {e}")
            import traceback
            traceback.print_exc()
            return False

def main():
    parser = argparse.ArgumentParser(description='将STEP文件转换为G代码')
    parser.add_argument('input_file', help='输入STEP文件路径')
    parser.add_argument('-o', '--output', help='输出G代码文件路径')
    parser.add_argument('-f', '--feed-rate', type=float, default=500, help='加工进给率 (mm/min)')
    parser.add_argument('-r', '--rapid-feed-rate', type=float, default=1000, help='快速移动进给率 (mm/min)')
    parser.add_argument('-s', '--safety-height', type=float, default=5.0, help='安全高度 (mm)')
    parser.add_argument('-d', '--cut-depth', type=float, default=0.5, help='每次切割深度 (mm)')
    parser.add_argument('-t', '--tool-diameter', type=float, default=3.0, help='刀具直径 (mm)')
    
    args = parser.parse_args()
    
    converter = StepToGcode(
        input_file=args.input_file,
        output_file=args.output,
        feed_rate=args.feed_rate,
        rapid_feed_rate=args.rapid_feed_rate,
        safety_height=args.safety_height,
        cut_depth=args.cut_depth,
        tool_diameter=args.tool_diameter
    )
    
    success = converter.convert()
    return 0 if success else 1

if __name__ == "__main__":
    sys.exit(main()) 